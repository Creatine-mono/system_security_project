"""
FastAPI backend exposing vulnerability tools over HTTP with history tracking.

Endpoints:
- /api/cve/{cve_id}
- /api/epss/{cve_id}
- /api/package/{package_name}
- /api/cvss
- /api/history (list) and /api/history/{id} (detail)
- /api/dashboard/summary (lightweight stats for dashboards)
"""

from __future__ import annotations

import asyncio
import sqlite3
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple

import mcp.types as types
from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field

from mcp_simple_tool.tools.cve_lookup import lookup_cve
from mcp_simple_tool.tools.cvss_calculator import calculate_cvss_score
from mcp_simple_tool.tools.epss_lookup import get_epss_score
from mcp_simple_tool.tools.package_vulnerability import (
    check_package_vulnerabilities,
)


class CVSSRequest(BaseModel):
    vector: str = Field(..., description="CVSS vector string (e.g. CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)")


class HistoryRecord(BaseModel):
    id: int
    action: str
    query: str
    status: str
    created_at: str
    result: Optional[str] = None


class HistoryStore:
    """Minimal SQLite-backed history store."""

    def __init__(self, db_path: Path):
        self.db_path = db_path

    def _connect(self) -> sqlite3.Connection:
        return sqlite3.connect(self.db_path)

    def _ensure_schema(self) -> None:
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        with self._connect() as conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    action TEXT NOT NULL,
                    query TEXT NOT NULL,
                    result TEXT NOT NULL,
                    status TEXT NOT NULL,
                    created_at TEXT NOT NULL
                )
                """
            )
            conn.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_history_action_created
                ON history(action, created_at DESC)
                """
            )
            conn.commit()

    async def init(self) -> None:
        await asyncio.to_thread(self._ensure_schema)

    async def add(self, action: str, query: str, result: str, status: str) -> int:
        def _insert() -> int:
            now = datetime.now(timezone.utc).isoformat()
            with self._connect() as conn:
                cursor = conn.execute(
                    """
                    INSERT INTO history (action, query, result, status, created_at)
                    VALUES (?, ?, ?, ?, ?)
                    """,
                    (action, query, result, status, now),
                )
                conn.commit()
                return int(cursor.lastrowid)

        return await asyncio.to_thread(_insert)

    async def list(self, action: Optional[str], limit: int) -> List[Dict[str, Any]]:
        def _list() -> List[Dict[str, Any]]:
            sql = "SELECT id, action, query, status, created_at FROM history"
            params: List[Any] = []
            if action:
                sql += " WHERE action = ?"
                params.append(action)
            sql += " ORDER BY datetime(created_at) DESC LIMIT ?"
            params.append(limit)

            with self._connect() as conn:
                rows = conn.execute(sql, params).fetchall()
                return [
                    {
                        "id": row[0],
                        "action": row[1],
                        "query": row[2],
                        "status": row[3],
                        "created_at": row[4],
                    }
                    for row in rows
                ]

        return await asyncio.to_thread(_list)

    async def get(self, history_id: int) -> Optional[Dict[str, Any]]:
        def _get() -> Optional[Dict[str, Any]]:
            with self._connect() as conn:
                row = conn.execute(
                    """
                    SELECT id, action, query, status, created_at, result
                    FROM history
                    WHERE id = ?
                    """,
                    (history_id,),
                ).fetchone()
                if not row:
                    return None
                return {
                    "id": row[0],
                    "action": row[1],
                    "query": row[2],
                    "status": row[3],
                    "created_at": row[4],
                    "result": row[5],
                }

        return await asyncio.to_thread(_get)

    async def summary(self) -> Dict[str, Any]:
        def _summary() -> Dict[str, Any]:
            with self._connect() as conn:
                total = conn.execute("SELECT COUNT(*) FROM history").fetchone()[0]
                by_action = conn.execute(
                    """
                    SELECT action, COUNT(*) AS count, MAX(created_at) AS last_run
                    FROM history
                    GROUP BY action
                    ORDER BY count DESC
                    """
                ).fetchall()
                recent = conn.execute(
                    """
                    SELECT id, action, query, status, created_at
                    FROM history
                    ORDER BY datetime(created_at) DESC
                    LIMIT 10
                    """
                ).fetchall()

                return {
                    "total": total,
                    "by_action": [
                        {"action": row[0], "count": row[1], "last_run": row[2]}
                        for row in by_action
                    ],
                    "recent": [
                        {
                            "id": row[0],
                            "action": row[1],
                            "query": row[2],
                            "status": row[3],
                            "created_at": row[4],
                        }
                        for row in recent
                    ],
                }

        return await asyncio.to_thread(_summary)


def _format_tool_output(content: Optional[Iterable[types.TextContent | types.ImageContent | types.EmbeddedResource]]) -> str:
    if not content:
        return ""
    parts: List[str] = []
    for item in content:
        text = getattr(item, "text", None)
        if text:
            parts.append(text)
        elif hasattr(item, "resource") and item.resource:  # EmbeddedResource
            parts.append(str(item.resource))
    return "\n\n".join(parts).strip()


async def run_tool_with_history(
    action: str,
    query: str,
    runner: Callable[[], Any],
    history_store: HistoryStore,
) -> Tuple[str, int, str]:
    status = "success"
    try:
        raw_result = await runner()
        result_text = _format_tool_output(raw_result) or "No content returned."
    except Exception as exc:  # noqa: BLE001 - surface the message to clients
        status = "error"
        result_text = f"Failed to execute {action}: {exc}"

    history_id = await history_store.add(action, query, result_text, status)
    return result_text, history_id, status


app = FastAPI(title="Vulnerability Intelligence API", version="0.1.0")
history_store = HistoryStore(Path(__file__).resolve().parent / "data" / "history.db")


@app.on_event("startup")
async def startup_event() -> None:
    await history_store.init()


@app.get("/health")
async def healthcheck() -> Dict[str, str]:
    return {"status": "ok"}


@app.get("/api/cve/{cve_id}")
async def api_cve_lookup(cve_id: str):
    result_text, history_id, status = await run_tool_with_history(
        "cve_lookup",
        cve_id,
        lambda: lookup_cve(cve_id),
        history_store,
    )

    if status != "success":
        return JSONResponse(
            status_code=502, content={"error": result_text, "historyId": history_id}
        )

    return {"result": result_text, "historyId": history_id}


@app.get("/api/epss/{cve_id}")
async def api_epss(cve_id: str):
    result_text, history_id, status = await run_tool_with_history(
        "epss_lookup",
        cve_id,
        lambda: get_epss_score(cve_id),
        history_store,
    )

    if status != "success":
        return JSONResponse(
            status_code=502, content={"error": result_text, "historyId": history_id}
        )

    return {"result": result_text, "historyId": history_id}


@app.get("/api/package/{package_name}")
async def api_package(package_name: str, version: Optional[str] = None):
    query = package_name if not version else f"{package_name}@{version}"
    result_text, history_id, status = await run_tool_with_history(
        "package_check",
        query,
        lambda: check_package_vulnerabilities(package_name, version),
        history_store,
    )

    if status != "success":
        return JSONResponse(
            status_code=502, content={"error": result_text, "historyId": history_id}
        )

    return {"result": result_text, "historyId": history_id}


@app.post("/api/cvss")
async def api_cvss(payload: CVSSRequest):
    result_text, history_id, status = await run_tool_with_history(
        "cvss_calculation",
        payload.vector,
        lambda: calculate_cvss_score(payload.vector),
        history_store,
    )

    if status != "success":
        return JSONResponse(
            status_code=400, content={"error": result_text, "historyId": history_id}
        )

    return {"result": result_text, "historyId": history_id}


@app.get("/api/history")
async def api_history(action: Optional[str] = None, limit: int = 50):
    safe_limit = max(1, min(limit, 200))
    items = await history_store.list(action, safe_limit)
    return {"items": items}


@app.get("/api/history/{history_id}")
async def api_history_detail(history_id: int):
    record = await history_store.get(history_id)
    if not record:
        raise HTTPException(status_code=404, detail="History record not found")
    return record


@app.get("/api/dashboard/summary")
async def api_dashboard_summary():
    return await history_store.summary()


def main() -> None:
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)


if __name__ == "__main__":
    main()
